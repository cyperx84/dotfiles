return {
  'epwalsh/obsidian.nvim',
  version = '*',
  lazy = true,
  ft = 'markdown',
  dependencies = {
    'nvim-lua/plenary.nvim',
  },
  config = function()
    require('obsidian').setup {
      workspaces = {
        {
          name = 'personal',
          path = vim.fn.expand '~/Library/Mobile Documents/iCloud~md~obsidian/Documents/notes',
        },
        {
          name = 'newvault',
          path = vim.fn.expand '~/Library/Mobile Documents/iCloud~md~obsidian/Documents/newvault',
        },
      },

      daily_notes = {
        folder = 'inbox',
        date_format = '%Y-%m-%d',
        alias_format = '%B %-d, %Y',
        default_tags = { 'daily-note' },
        template = nil,
      },

      completion = {
        nvim_cmp = true,
        min_chars = 2,
      },

      -- New notes location (constitution: all notes live in root)
      new_notes_location = 'current_dir', -- Notes go to root/current directory

      -- Note ID function - creates URL-friendly slugs
      note_id_func = function(title)
        if title == nil or title == '' then
          return tostring(os.time()) -- fallback to timestamp
        end
        local slug = title
          :gsub('^%s*(.-)%s*$', '%1') -- trim whitespace
          :gsub('%s+', '-') -- spaces â†’ dashes
          :gsub('[^%w%-]', '') -- strip punctuation/symbols
        return slug
      end,

      -- Note path function - organize notes by creation date (optional)
      -- Uncomment to organize notes into year/month folders
      -- note_path_func = function(spec)
      --   local path = spec.dir / os.date('%Y/%m') / tostring(spec.id)
      --   return path:with_suffix('.md')
      -- end,

      -- Enhanced frontmatter aligned with vault constitution
      note_frontmatter_func = function(note)
        -- Get current timestamp
        local now = os.date '%Y-%m-%d %H:%M'

        -- Preserve existing created date or use current time for new notes
        local created_date = (note.metadata and note.metadata.created) or now

        -- NOTE: Tags should NOT have hashtag prefix in frontmatter
        -- The obsidian.nvim plugin expects tags in YAML format without '#'
        -- YAML format (correct for tag search):
        --   tags: [type/fleeting-note, status/active]
        -- NOT hashtag format (breaks tag filtering):
        --   tags: [#type/fleeting-note, #status/active]

        local out = {
          id = note.id,
          title = note.title or '',
          created = created_date, -- Preserve original or set once
          modified = now, -- Always update to current time
          reviewed = nil, -- Last review date (weekly gardening ritual)
          tags = note.tags or {}, -- Tags without hashtag prefix
          aliases = note.aliases or {},
          base = nil, -- Which Obsidian Base context this belongs to
        }

        -- Preserve other existing metadata (but not created/modified)
        if note.metadata ~= nil and not vim.tbl_isempty(note.metadata) then
          for k, v in pairs(note.metadata) do
            if k ~= 'created' and k ~= 'modified' then
              out[k] = v
            end
          end
        end

        return out
      end,

      -- Disable frontmatter for files outside the vault
      disable_frontmatter = function(filename)
        local vault_path = vim.fn.expand '~/Library/Mobile Documents/iCloud~md~obsidian/Documents/notes'
        local absolute_filename = vim.fn.fnamemodify(filename, ':p')

        -- Only apply frontmatter to files within the vault
        if not absolute_filename:match('^' .. vim.pesc(vault_path)) then
          return true -- disable frontmatter
        end

        return false -- enable frontmatter
      end,

      -- Attachments (images, files) - Constitution doesn't specify, keeping sensible default
      attachments = {
        img_folder = 'assets/imgs',
        ---@param client obsidian.Client
        ---@param path obsidian.Path
        ---@return string
        img_text_func = function(client, path)
          path = client:vault_relative_path(path) or path
          return string.format('![%s](%s)', path.name, path)
        end,
      },

      -- Link style preferences (constitution: "Links are primary")
      preferred_link_style = 'wiki', -- Wiki-style links for bi-directional linking
      wiki_link_func = 'use_alias_only', -- Use aliases for cleaner link text

      -- Open URLs in browser
      follow_url_func = function(url)
        vim.fn.jobstart({ 'open', url }, { detach = true })
      end,

      -- Enhanced keymaps
      mappings = {
        -- Override 'gf' to work on markdown/wiki links
        ['gf'] = {
          action = function()
            return require('obsidian').util.gf_passthrough()
          end,
          opts = { noremap = false, expr = true, buffer = true },
        },
        -- Toggle checkboxes
        ['<leader>ch'] = {
          action = function()
            return require('obsidian').util.toggle_checkbox()
          end,
          opts = { buffer = true, desc = 'Toggle [Ch]eckbox' },
        },
        -- Smart action (context-aware: follow link or toggle checkbox)
        ['<cr>'] = {
          action = function()
            return require('obsidian').util.smart_action()
          end,
          opts = { buffer = true, expr = true, desc = 'Smart action' },
        },
      },

      -- Picker configuration
      picker = {
        name = 'telescope.nvim',
        note_mappings = {
          new = '<C-x>',
          insert_link = '<C-l>',
        },
        tag_mappings = {
          tag_note = '<C-x>',
          insert_tag = '<C-l>',
        },
        sort_by = 'modified',
        sort_reversed = true,
      },

      -- UI settings (disabled in favor of render-markdown.nvim)
      ui = {
        enable = false,
      },

      -- YAML parser
      yaml_parser = 'native',
    }

    -- Enhanced autocmd for markdown files
    -- Constitution: "Neovim primary interface" - comprehensive keymaps below
    vim.api.nvim_create_autocmd('FileType', {
      pattern = 'markdown',
      callback = function()
        -- Auto-reload settings for external changes (e.g., from Obsidian app)
        vim.opt_local.autoread = true

        -- Conceal settings
        vim.opt_local.conceallevel = 2
        vim.opt_local.concealcursor = 'nc'

        -- Obsidian command keymaps (aligned with constitution workflow)
        local opts = { buffer = true }

        -- Checkbox operations
        vim.keymap.set('n', '<leader>oc', function()
          return require('obsidian').util.toggle_checkbox()
        end, vim.tbl_extend('force', opts, { desc = '[O]bsidian Toggle [C]heckbox' }))
        vim.keymap.set('v', '<leader>oc', function()
          -- Get current visual selection (works while in visual mode)
          local start_line = vim.fn.line 'v'
          local end_line = vim.fn.line '.'

          -- Ensure start is before end
          if start_line > end_line then
            start_line, end_line = end_line, start_line
          end

          -- Exit visual mode
          vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes('<Esc>', true, false, true), 'x', false)

          -- Process each line
          for line = start_line, end_line do
            vim.api.nvim_win_set_cursor(0, { line, 0 })
            require('obsidian').util.toggle_checkbox()
          end
        end, vim.tbl_extend('force', opts, { desc = '[O]bsidian Toggle [C]heckbox (Visual)' }))

        -- Table-driven keymap definitions
        local keymaps = {
          -- Note operations
          { 'n', '<leader>on', ':ObsidianNew<CR>', '[O]bsidian [N]ew note' },
          { 'n', '<leader>oo', ':ObsidianOpen<CR>', '[O]bsidian [O]pen in app' },
          { 'n', '<leader>of', ':ObsidianQuickSwitch<CR>', '[O]bsidian [Q]uick switch' },

          -- Search operations
          { 'n', '<leader>os', ':ObsidianSearch<CR>', '[O]bsidian [S]earch' },
          { 'n', '<leader>ob', ':ObsidianBacklinks<CR>', '[O]bsidian [B]acklinks' },
          { 'n', '<leader>ol', ':ObsidianLinks<CR>', '[O]bsidian [L]inks' },
          { 'n', '<leader>ot', ':ObsidianTags<CR>', '[O]bsidian [T]ags' },

          -- Daily notes
          { 'n', '<leader>od', ':ObsidianToday<CR>', '[O]bsidian Today ([D]aily)' },
          { 'n', '<leader>oy', ':ObsidianYesterday<CR>', '[O]bsidian [Y]esterday' },
          { 'n', '<leader>om', ':ObsidianTomorrow<CR>', '[O]bsidian To[m]orrow' },

          -- Link operations (normal mode)
          { 'n', '<leader>oF', ':ObsidianFollowLink<CR>', '[O]bsidian [F]ollow link' },

          -- Utility
          { 'n', '<leader>oi', ':ObsidianPasteImg<CR>', '[O]bsidian Paste [I]mage' },
          { 'n', '<leader>or', '<cmd>ObsidianRename<CR>', '[O]bsidian [R]ename' },
          { 'n', '<leader>ow', ':ObsidianWorkspace<CR>', '[O]bsidian [W]orkspace' },
          { 'n', '<leader>ox', ':ObsidianTOC<CR>', '[O]bsidian Table of Contents' },
        }

        -- Visual mode keymaps
        local visual_keymaps = {
          { 'v', '<leader>oe', ':ObsidianExtractNote<CR>', '[O]bsidian [E]xtract note' },
          { 'v', '<leader>oL', ':ObsidianLink<CR>', '[O]bsidian [L]ink selection' },
          { 'v', '<leader>oln', ':ObsidianLinkNew<CR>', '[O]bsidian [L]ink [N]ew' },
        }

        -- Set all keymaps using iteration
        for _, keymap in ipairs(keymaps) do
          local mode, lhs, rhs, desc = unpack(keymap)
          vim.keymap.set(mode, lhs, rhs, vim.tbl_extend('force', opts, { desc = desc }))
        end

        for _, keymap in ipairs(visual_keymaps) do
          local mode, lhs, rhs, desc = unpack(keymap)
          vim.keymap.set(mode, lhs, rhs, vim.tbl_extend('force', opts, { desc = desc }))
        end
      end,
    })

    -- Auto-reload markdown files when changed externally
    -- Triggers on focus gain, buffer enter, and cursor hold
    vim.api.nvim_create_autocmd({ 'FocusGained', 'BufEnter', 'CursorHold' }, {
      pattern = '*.md',
      callback = function()
        if vim.fn.mode() ~= 'c' then -- Don't reload in command mode
          vim.cmd 'checktime'
        end
      end,
      desc = 'Auto-reload markdown files when changed externally',
    })

    -- Custom tag search (workaround for ObsidianTags issues)
    -- Enhanced with tag_note and insert_tag mappings to add/insert tags
    --
    -- Keymaps in Tag Picker:
    --   <CR>  - Show all files with selected tag
    --   <C-x> - Add tag to current note's frontmatter
    --   <C-l> - Insert tag as inline text (#tag)
    --
    -- Keymaps in File Picker (after selecting tag):
    --   <CR>  - Open file in current buffer
    --   <C-v> - Open file in vertical split
    --   <C-x> - Open file in horizontal split
    --   <C-t> - Open file in new tab
    local function vault_tag_search()
      -- Get current vault path dynamically (works across all workspaces)
      local client = require('obsidian').get_client()
      local vault_path = tostring(client:vault_root())
      local telescope = require 'telescope.builtin'
      local pickers = require 'telescope.pickers'
      local finders = require 'telescope.finders'
      local conf = require('telescope.config').values
      local actions = require 'telescope.actions'
      local action_state = require 'telescope.actions.state'
      local previewers = require 'telescope.previewers'

      -- Use Python script for robust tag extraction
      local extract_script = vim.fn.stdpath 'config' .. '/scripts/extract-tags.py'
      local cmd = string.format("cd '%s' && python3 '%s' list", vault_path, extract_script)

      local handle = io.popen(cmd)
      if not handle then
        vim.notify('Failed to extract tags', vim.log.levels.ERROR)
        return
      end
      local result = handle:read '*a'
      handle:close()

      local tags = {}
      for tag in result:gmatch '[^\n]+' do
        if tag ~= '' and not tag:match '^%s*$' then
          table.insert(tags, tag)
        end
      end

      if #tags == 0 then
        vim.notify('No tags found in vault', vim.log.levels.WARN)
        return
      end

      -- Show tag picker
      pickers
        .new({}, {
          prompt_title = 'Vault Tags | <CR> files | <C-x> add to note | <C-l> insert',
          finder = finders.new_table { results = tags },
          sorter = conf.generic_sorter {},
          attach_mappings = function(prompt_bufnr, map)
            -- Ctrl+X - Add tag to current note's frontmatter
            map('i', '<C-x>', function()
              local selection = action_state.get_selected_entry()
              local tag = selection[1]
              actions.close(prompt_bufnr)

              -- Get current note and add tag
              local client = require('obsidian').get_client()
              local note = client:current_note()
              if note then
                if not note:has_tag(tag) then
                  note:add_tag(tag)
                  client:write_note(note)
                  vim.notify('Added tag: ' .. tag, vim.log.levels.INFO)
                else
                  vim.notify('Tag already present: ' .. tag, vim.log.levels.WARN)
                end
              else
                vim.notify('Not in an Obsidian note', vim.log.levels.ERROR)
              end
            end)

            -- Ctrl+L - Insert tag as inline text
            map('i', '<C-l>', function()
              local selection = action_state.get_selected_entry()
              local tag = selection[1]
              actions.close(prompt_bufnr)
              vim.api.nvim_put({ '#' .. tag }, 'c', true, true)
            end)

            -- Default action - show files with selected tag
            actions.select_default:replace(function()
              local selection = action_state.get_selected_entry()
              local selected_tag = selection[1]
              actions.close(prompt_bufnr)

              -- Use Python script for robust file search
              local files_cmd = string.format("cd '%s' && python3 '%s' find '%s'", vault_path, extract_script, selected_tag:gsub("'", "'\"'\"'"))

              local files_handle = io.popen(files_cmd)
              if not files_handle then
                vim.notify('Failed to search for files with tag', vim.log.levels.ERROR)
                return
              end
              local files_result = files_handle:read '*a'
              files_handle:close()

              local files = {}
              for file in files_result:gmatch '[^\n]+' do
                if file ~= '' then
                  table.insert(files, file)
                end
              end

              if #files == 0 then
                vim.notify('No files found with tag: ' .. selection[1], vim.log.levels.WARN)
                return
              end

              -- Show files picker
              pickers
                .new({}, {
                  prompt_title = 'Files with tag: ' .. selection[1] .. ' | <CR> open | <C-v> vsplit | <C-x> split',
                  finder = finders.new_table {
                    results = files,
                    entry_maker = function(entry)
                      return {
                        value = entry,
                        display = entry,
                        ordinal = entry,
                        path = vault_path .. '/' .. entry,
                      }
                    end,
                  },
                  sorter = conf.generic_sorter {},
                  previewer = previewers.vim_buffer_cat.new {},
                })
                :find()
            end)
            return true
          end,
        })
        :find()
    end

    -- Custom links search (shows outgoing links from current file)
    --
    -- Keymaps in Link Picker:
    --   <CR>  - Open linked file
    --   <C-v> - Open in vertical split
    --   <C-x> - Open in horizontal split
    local function vault_links_search()
      -- Get current vault path dynamically (works across all workspaces)
      local client = require('obsidian').get_client()
      local vault_path = tostring(client:vault_root())
      local extract_script = vim.fn.stdpath 'config' .. '/scripts/extract-links.py'
      local pickers = require 'telescope.pickers'
      local finders = require 'telescope.finders'
      local conf = require('telescope.config').values
      local previewers = require 'telescope.previewers'

      -- Get current file relative to vault
      local current_file = vim.fn.expand '%:p'
      local relative_file = current_file:gsub('^' .. vim.pesc(vault_path) .. '/', '')

      -- Debug: Show what file we're searching
      vim.notify('Searching links in: ' .. relative_file, vim.log.levels.INFO)

      -- Get outgoing links from current file
      local cmd = string.format("cd '%s' && python3 '%s' links '%s' 2>&1", vault_path, extract_script, relative_file:gsub("'", "'\"'\"'"))
      local handle = io.popen(cmd)
      if not handle then
        vim.notify('Failed to extract links', vim.log.levels.ERROR)
        return
      end
      local result = handle:read '*a'
      local exit_code = handle:close()

      -- Debug: Check for errors
      if result:match '^Traceback' or result:match '^Usage:' or result:match '^Error' then
        vim.notify('Link extraction error: ' .. result:sub(1, 200), vim.log.levels.ERROR)
        return
      end

      -- Parse results: link_text|target_file|exists
      local links = {}
      local link_data = {}
      for line in result:gmatch '[^\n]+' do
        local link_text, target_file, exists = line:match '([^|]+)|([^|]+)|([^|]+)'
        if target_file then
          local display_text = link_text .. (exists == 'exists' and '' or ' [missing]')
          table.insert(links, display_text)
          link_data[display_text] = {
            path = vault_path .. '/' .. target_file,
            link_text = link_text,
            exists = exists == 'exists',
          }
        end
      end

      -- Debug: Show how many links were found
      vim.notify('Found ' .. #links .. ' links', vim.log.levels.INFO)

      if #links == 0 then
        vim.notify('No outgoing links found in current file', vim.log.levels.WARN)
        return
      end

      -- Show links picker
      pickers
        .new({}, {
          prompt_title = 'Links from: ' .. vim.fn.expand '%:t' .. ' | <CR> open | <C-v> vsplit | <C-x> split',
          finder = finders.new_table {
            results = links,
            entry_maker = function(entry)
              local data = link_data[entry]
              return {
                value = entry,
                display = entry,
                ordinal = entry,
                path = data.path,
              }
            end,
          },
          sorter = conf.generic_sorter {},
          previewer = previewers.vim_buffer_cat.new {},
        })
        :find()
    end

    -- Custom backlinks search (shows files that link to current file)
    --
    -- Keymaps in Backlinks Picker:
    --   <CR>  - Open file with backlink
    --   <C-v> - Open in vertical split
    --   <C-x> - Open in horizontal split
    local function vault_backlinks_search()
      -- Get current vault path dynamically (works across all workspaces)
      local client = require('obsidian').get_client()
      local vault_path = tostring(client:vault_root())
      local extract_script = vim.fn.stdpath 'config' .. '/scripts/extract-links.py'
      local pickers = require 'telescope.pickers'
      local finders = require 'telescope.finders'
      local conf = require('telescope.config').values
      local previewers = require 'telescope.previewers'

      -- Get current file relative to vault
      local current_file = vim.fn.expand '%:p'
      local relative_file = current_file:gsub('^' .. vim.pesc(vault_path) .. '/', '')

      -- Debug: Show what file we're searching
      vim.notify('Searching backlinks to: ' .. relative_file, vim.log.levels.INFO)

      -- Get backlinks to current file
      local cmd = string.format("cd '%s' && python3 '%s' backlinks '%s' 2>&1", vault_path, extract_script, relative_file:gsub("'", "'\"'\"'"))
      local handle = io.popen(cmd)
      if not handle then
        vim.notify('Failed to extract backlinks', vim.log.levels.ERROR)
        return
      end
      local result = handle:read '*a'
      local exit_code = handle:close()

      -- Debug: Check for errors
      if result:match '^Traceback' or result:match '^Usage:' or result:match '^Error' then
        vim.notify('Backlink extraction error: ' .. result:sub(1, 200), vim.log.levels.ERROR)
        return
      end

      -- Parse results: source_file|link_text
      local backlinks = {}
      local backlink_paths = {}
      for line in result:gmatch '[^\n]+' do
        local source_file, link_text = line:match '([^|]+)|([^|]+)'
        if source_file then
          table.insert(backlinks, source_file)
          backlink_paths[source_file] = vault_path .. '/' .. source_file
        end
      end

      -- Debug: Show how many backlinks were found
      vim.notify('Found ' .. #backlinks .. ' backlinks', vim.log.levels.INFO)

      if #backlinks == 0 then
        vim.notify('No backlinks found to current file', vim.log.levels.WARN)
        return
      end

      -- Show backlinks picker
      pickers
        .new({}, {
          prompt_title = 'Backlinks to: ' .. vim.fn.expand '%:t' .. ' | <CR> open | <C-v> vsplit | <C-x> split',
          finder = finders.new_table {
            results = backlinks,
            entry_maker = function(entry)
              return {
                value = entry,
                display = entry,
                ordinal = entry,
                path = backlink_paths[entry],
              }
            end,
          },
          sorter = conf.generic_sorter {},
          previewer = previewers.vim_buffer_cat.new {},
        })
        :find()
    end

    -- Create custom command and keymap
    vim.api.nvim_create_user_command('VaultTags', vault_tag_search, {})
    vim.keymap.set('n', '<leader>oT', vault_tag_search, { buffer = false, desc = '[O]bsidian [T]ags (custom vault search)' })

    -- Override the built-in commands with our fixed versions
    -- This makes the original commands use Python-based search
    vim.defer_fn(function()
      vim.api.nvim_create_user_command('ObsidianTags', vault_tag_search, { force = true })
      vim.api.nvim_create_user_command('ObsidianLinks', vault_links_search, { force = true })
      vim.api.nvim_create_user_command('ObsidianBacklinks', vault_backlinks_search, { force = true })
    end, 100)
  end,
}
